diff -rup httpd-2.2.34.orig/acinclude.m4 httpd-2.2.34/acinclude.m4
--- httpd-2.2.34.orig/acinclude.m4	2012-07-06 17:23:21.000000000 +0200
+++ httpd-2.2.34/acinclude.m4	2017-11-19 22:20:08.394993999 +0100
@@ -453,7 +453,7 @@ if test "x$ap_ssltk_configured" = "x"; t
   liberrors=""
   if test "$ap_ssltk_type" = "openssl"; then
     AC_CHECK_HEADERS([openssl/engine.h])
-    AC_CHECK_FUNCS([SSLeay_version SSL_CTX_new], [], [liberrors="yes"])
+    AC_CHECK_FUNCS([SSL_CTX_new], [], [liberrors="yes"])
     AC_CHECK_FUNCS([ENGINE_init ENGINE_load_builtin_engines])
   else
     AC_CHECK_FUNCS([SSLC_library_version SSL_CTX_new], [], [liberrors="yes"])
diff -rup httpd-2.2.34.orig/modules/ssl/mod_ssl.c httpd-2.2.34/modules/ssl/mod_ssl.c
--- httpd-2.2.34.orig/modules/ssl/mod_ssl.c	2017-01-05 19:57:49.000000000 +0100
+++ httpd-2.2.34/modules/ssl/mod_ssl.c	2017-11-19 22:20:08.395993990 +0100
@@ -272,7 +272,14 @@ static apr_status_t ssl_cleanup_pre_conf
 #if HAVE_ENGINE_LOAD_BUILTIN_ENGINES
     ENGINE_cleanup();
 #endif
+
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
+#if OPENSSL_VERSION_NUMBER >= 0x1000000fL
+    ERR_remove_thread_state(NULL);
+#else
     ERR_remove_state(0);
+#endif
+#endif
 
     /* Don't call ERR_free_strings here; ERR_load_*_strings only
      * actually load the error strings once per process due to static
@@ -299,7 +306,11 @@ static int ssl_hook_pre_config(apr_pool_
     /* We must register the library in full, to ensure our configuration
      * code can successfully test the SSL environment.
      */
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
     CRYPTO_malloc_init();
+#else
+    OPENSSL_malloc_init();
+#endif
 #ifdef HAVE_OPENSSL
     ERR_load_crypto_strings();
 #endif
diff -rup httpd-2.2.34.orig/modules/ssl/ssl_engine_init.c httpd-2.2.34/modules/ssl/ssl_engine_init.c
--- httpd-2.2.34.orig/modules/ssl/ssl_engine_init.c	2017-01-05 19:57:49.000000000 +0100
+++ httpd-2.2.34/modules/ssl/ssl_engine_init.c	2017-11-19 22:21:47.098154731 +0100
@@ -229,6 +229,10 @@ int ssl_init_Module(apr_pool_t *p, apr_p
 
     SSL_init_app_data2_idx(); /* for SSL_get_app_data2() at request time */
 
+#if ! MODSSL_USE_OPENSSL_PRE_1_1_API
+    init_bio_methods();
+#endif
+
     return OK;
 }
 
@@ -340,6 +344,9 @@ static void ssl_init_ctx_protocol(server
     char *cp;
     int protocol = mctx->protocol;
     SSLSrvConfigRec *sc = mySrvConfig(s);
+#if ! MODSSL_USE_OPENSSL_PRE_1_1_API
+    int prot;
+#endif
 
     /*
      *  Create the new per-server SSL context
@@ -368,6 +375,7 @@ static void ssl_init_ctx_protocol(server
     ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
                  "Creating new SSL context (protocols: %s)", cp);
 
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
 #ifndef OPENSSL_NO_SSL2
     if (protocol == SSL_PROTOCOL_SSLV2) {
         method = mctx->pkp ?
@@ -408,12 +416,18 @@ static void ssl_init_ctx_protocol(server
             SSLv23_client_method() : /* proxy */
             SSLv23_server_method();  /* server */
     }
+#else
+    method = mctx->pkp ?
+        TLS_client_method() : /* proxy */
+        TLS_server_method();  /* server */
+#endif
     ctx = SSL_CTX_new(method);
 
     mctx->ssl_ctx = ctx;
 
     SSL_CTX_set_options(ctx, SSL_OP_ALL);
 
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
 #ifndef OPENSSL_NO_SSL2
     if (!(protocol & SSL_PROTOCOL_SSLV2)) {
         SSL_CTX_set_options(ctx, SSL_OP_NO_SSLv2);
@@ -440,6 +454,43 @@ static void ssl_init_ctx_protocol(server
     }
 #endif
 
+#else /* #if MODSSL_USE_OPENSSL_PRE_1_1_API */
+    /* We first determine the maximum protocol version we should provide */
+    if (protocol & SSL_PROTOCOL_TLSV1_2) {
+        prot = TLS1_2_VERSION;
+    } else if (protocol & SSL_PROTOCOL_TLSV1_1) {
+        prot = TLS1_1_VERSION;
+    } else if (protocol & SSL_PROTOCOL_TLSV1) {
+        prot = TLS1_VERSION;
+#ifndef OPENSSL_NO_SSL3
+    } else if (protocol & SSL_PROTOCOL_SSLV3) {
+        prot = SSL3_VERSION;
+#endif
+    } else {
+        SSL_CTX_free(ctx);
+        mctx->ssl_ctx = NULL;
+        ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s,
+                "No SSL protocols available [hint: SSLProtocol]");
+        return ssl_die();
+    }
+    SSL_CTX_set_max_proto_version(ctx, prot);
+
+    /* Next we scan for the minimal protocol version we should provide,
+     * but we do not allow holes between max and min */
+    if (prot == TLS1_2_VERSION && protocol & SSL_PROTOCOL_TLSV1_1) {
+        prot = TLS1_1_VERSION;
+    }
+    if (prot == TLS1_1_VERSION && protocol & SSL_PROTOCOL_TLSV1) {
+        prot = TLS1_VERSION;
+    }
+#ifndef OPENSSL_NO_SSL3
+    if (prot == TLS1_VERSION && protocol & SSL_PROTOCOL_SSLV3) {
+        prot = SSL3_VERSION;
+    }
+#endif
+    SSL_CTX_set_min_proto_version(ctx, prot);
+#endif /* if MODSSL_USE_OPENSSL_PRE_1_1_API */
+
 #ifdef SSL_OP_CIPHER_SERVER_PREFERENCE
     if (sc->cipher_server_pref == TRUE) {
         SSL_CTX_set_options(ctx, SSL_OP_CIPHER_SERVER_PREFERENCE);
@@ -673,6 +724,67 @@ static void ssl_init_ctx_crl(server_rec
     }
 }
 
+/*
+ * Read a file that optionally contains the server certificate in PEM
+ * format, possibly followed by a sequence of CA certificates that
+ * should be sent to the peer in the SSL Certificate message.
+ */
+#if ! MODSSL_USE_OPENSSL_PRE_1_1_API
+static int use_certificate_chain(
+    SSL_CTX *ctx, char *file, int skipfirst, pem_password_cb *cb)
+{
+    BIO *bio;
+    X509 *x509;
+    unsigned long err;
+    int n;
+
+    if ((bio = BIO_new(BIO_s_file())) == NULL)
+        return -1;
+    if (BIO_read_filename(bio, file) <= 0) {
+        BIO_free(bio);
+        return -1;
+    }
+    /* optionally skip a leading server certificate */
+    if (skipfirst) {
+        if ((x509 = PEM_read_bio_X509(bio, NULL, cb, NULL)) == NULL) {
+            BIO_free(bio);
+            return -1;
+        }
+        X509_free(x509);
+    }
+    /* free a perhaps already configured extra chain */
+#ifdef OPENSSL_NO_SSL_INTERN
+    SSL_CTX_clear_extra_chain_certs(ctx);
+#else
+    if (ctx->extra_certs != NULL) {
+        sk_X509_pop_free((STACK_OF(X509) *)ctx->extra_certs, X509_free);
+        ctx->extra_certs = NULL;
+    }
+#endif
+    /* create new extra chain by loading the certs */
+    n = 0;
+    while ((x509 = PEM_read_bio_X509(bio, NULL, cb, NULL)) != NULL) {
+        if (!SSL_CTX_add_extra_chain_cert(ctx, x509)) {
+            X509_free(x509);
+            BIO_free(bio);
+            return -1;
+        }
+        n++;
+    }
+    /* Make sure that only the error is just an EOF */
+    if ((err = ERR_peek_error()) > 0) {
+        if (!(   ERR_GET_LIB(err) == ERR_LIB_PEM
+              && ERR_GET_REASON(err) == PEM_R_NO_START_LINE)) {
+            BIO_free(bio);
+            return -1;
+        }
+        while (ERR_get_error() > 0) ;
+    }
+    BIO_free(bio);
+    return n;
+}
+#endif
+
 static void ssl_init_ctx_cert_chain(server_rec *s,
                                     apr_pool_t *p,
                                     apr_pool_t *ptemp,
@@ -708,9 +820,14 @@ static void ssl_init_ctx_cert_chain(serv
     }
 
     ERR_clear_error();
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
     n = SSL_CTX_use_certificate_chain(mctx->ssl_ctx,
                                       (char *)chain,
                                       skip_first, NULL);
+#else
+    n = use_certificate_chain(mctx->ssl_ctx, (char *)chain, skip_first, NULL);
+#endif
+
     if (n < 0) {
         ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
                 "Failed to configure CA certificate chain!");
@@ -922,7 +1039,7 @@ static void ssl_init_server_certs(server
     int nid;
     EC_KEY *eckey = NULL;
 #endif
-    const char *vhost_id = mctx->sc->vhost_id;
+    const char *vhost_id = mctx->sc->vhost_id, *certfile;
     int i;
     int have_rsa, have_dsa;
     DH *dhparams;
@@ -984,13 +1101,18 @@ static void ssl_init_server_certs(server
     /*
      * Try to read DH parameters from the (first) SSLCertificateFile
      */
-    if ((mctx->pks->cert_files[0] != NULL) &&
-        (dhparams = ssl_dh_GetParamFromFile(mctx->pks->cert_files[0]))) {
+    if ((certfile = mctx->pks->cert_files[0]) &&
+        (dhparams = ssl_dh_GetParamFromFile(certfile))) {
         SSL_CTX_set_tmp_dh(mctx->ssl_ctx, dhparams);
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
+        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
+                     "Custom DH parameters (%d bits) for %s loaded from %s",
+                     BN_num_bits(dhparams->p), vhost_id, certfile);
+#else
         ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
                      "Custom DH parameters (%d bits) for %s loaded from %s",
-                     BN_num_bits(dhparams->p), vhost_id,
-                     mctx->pks->cert_files[0]);
+                     DH_bits(dhparams), vhost_id, certfile);
+#endif
         DH_free(dhparams);
     }
 
@@ -1011,6 +1133,7 @@ static void ssl_init_server_certs(server
      * ...otherwise, enable auto curve selection (OpenSSL 1.0.2 and later)
      * or configure NIST P-256 (required to enable ECDHE for earlier versions)
      */
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
     else {
 #if defined(SSL_CTX_set_ecdh_auto)
         SSL_CTX_set_ecdh_auto(mctx->ssl_ctx, 1);
@@ -1019,6 +1142,7 @@ static void ssl_init_server_certs(server
         SSL_CTX_set_tmp_ecdh(mctx->ssl_ctx, eckey);
 #endif
     }
+#endif
     EC_KEY_free(eckey);
     EC_GROUP_free(ecparams);
 #endif
@@ -1567,6 +1691,10 @@ apr_status_t ssl_init_ModuleKill(void *d
         ssl_init_ctx_cleanup_server(sc->server);
     }
 
+#if ! MODSSL_USE_OPENSSL_PRE_1_1_API
+    free_bio_methods();
+#endif
+
     return APR_SUCCESS;
 }
 
diff -rup httpd-2.2.34.orig/modules/ssl/ssl_engine_io.c httpd-2.2.34/modules/ssl/ssl_engine_io.c
--- httpd-2.2.34.orig/modules/ssl/ssl_engine_io.c	2017-06-19 18:52:00.000000000 +0200
+++ httpd-2.2.34/modules/ssl/ssl_engine_io.c	2017-11-19 22:20:08.395993990 +0100
@@ -132,7 +132,11 @@ static bio_filter_out_ctx_t *bio_filter_
 
 static int bio_filter_out_flush(BIO *bio)
 {
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
     bio_filter_out_ctx_t *outctx = (bio_filter_out_ctx_t *)(bio->ptr);
+#else
+    bio_filter_out_ctx_t *outctx = (bio_filter_out_ctx_t *)BIO_get_data(bio);
+#endif
     apr_bucket *e;
 
     if (!(outctx->blen || outctx->length)) {
@@ -165,10 +169,20 @@ static int bio_filter_out_flush(BIO *bio
 
 static int bio_filter_create(BIO *bio)
 {
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
     bio->shutdown = 1;
     bio->init = 1;
+    /* No setter method for OpenSSL 1.1.0 available,
+     * but I can't find any functional use of the
+     * "num" field there either.
+     */
     bio->num = -1;
     bio->ptr = NULL;
+#else
+    BIO_set_shutdown(bio, 1);
+    BIO_set_init(bio, 1);
+    BIO_set_data(bio, NULL);
+#endif
 
     return 1;
 }
@@ -193,7 +207,11 @@ static int bio_filter_out_read(BIO *bio,
 
 static int bio_filter_out_write(BIO *bio, const char *in, int inl)
 {
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
     bio_filter_out_ctx_t *outctx = (bio_filter_out_ctx_t *)(bio->ptr);
+#else
+    bio_filter_out_ctx_t *outctx = (bio_filter_out_ctx_t *)BIO_get_data(bio);
+#endif
     
     /* Abort early if the client has initiated a renegotiation. */
     if (outctx->filter_ctx->config->reneg_state == RENEG_ABORT) {
@@ -243,7 +261,11 @@ static long bio_filter_out_ctrl(BIO *bio
     long ret = 1;
     char **pptr;
 
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
     bio_filter_out_ctx_t *outctx = (bio_filter_out_ctx_t *)(bio->ptr);
+#else
+    bio_filter_out_ctx_t *outctx = (bio_filter_out_ctx_t *)BIO_get_data(bio);
+#endif
 
     switch (cmd) {
       case BIO_CTRL_RESET:
@@ -263,10 +285,18 @@ static long bio_filter_out_ctrl(BIO *bio
         }
         break;
       case BIO_CTRL_GET_CLOSE:
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
         ret = (long)bio->shutdown;
+#else
+        ret = (long)BIO_get_shutdown(bio);
+#endif
         break;
       case BIO_CTRL_SET_CLOSE:
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
         bio->shutdown = (int)num;
+#else
+        BIO_set_shutdown(bio, (int)num);
+#endif
         break;
       case BIO_CTRL_WPENDING:
         ret = 0L;
@@ -306,20 +336,6 @@ static int bio_filter_out_puts(BIO *bio,
     return -1;
 }
 
-static BIO_METHOD bio_filter_out_method = {
-    BIO_TYPE_MEM,
-    "APR output filter",
-    bio_filter_out_write,
-    bio_filter_out_read,     /* read is never called */
-    bio_filter_out_puts,     /* puts is never called */
-    bio_filter_out_gets,     /* gets is never called */
-    bio_filter_out_ctrl,
-    bio_filter_create,
-    bio_filter_destroy,
-#ifdef OPENSSL_VERSION_NUMBER
-    NULL /* sslc does not have the callback_ctrl field */
-#endif
-};
 
 typedef struct {
     int length;
@@ -470,7 +486,11 @@ static apr_status_t brigade_consume(apr_
 static int bio_filter_in_read(BIO *bio, char *in, int inlen)
 {
     apr_size_t inl = inlen;
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
     bio_filter_in_ctx_t *inctx = (bio_filter_in_ctx_t *)(bio->ptr);
+#else
+    bio_filter_in_ctx_t *inctx = (bio_filter_in_ctx_t *)BIO_get_data(bio);
+#endif
     apr_read_type_e block = inctx->block;
 
     inctx->rc = APR_SUCCESS;
@@ -495,7 +515,11 @@ static int bio_filter_in_read(BIO *bio,
      * unconditionally should be minimal.
      */
     if (bio_filter_out_flush(inctx->bio_out) < 0) {
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
         bio_filter_out_ctx_t *outctx = inctx->bio_out->ptr;
+#else
+        bio_filter_out_ctx_t *outctx = BIO_get_data(inctx->bio_out);
+#endif
         inctx->rc = outctx->rc;
         return -1;
     }
@@ -559,6 +583,41 @@ static int bio_filter_in_read(BIO *bio,
     return -1;
 }
 
+static int bio_filter_in_write(BIO *bio, const char *in, int inl)
+{
+    return -1;
+}
+
+static int bio_filter_in_puts(BIO *bio, const char *str)
+{
+    return -1;
+}
+
+static int bio_filter_in_gets(BIO *bio, char *buf, int size)
+{
+    return -1;
+}
+
+static long bio_filter_in_ctrl(BIO *bio, int cmd, long num, void *ptr)
+{
+    return -1;
+}
+
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
+static BIO_METHOD bio_filter_out_method = {
+    BIO_TYPE_MEM,
+    "APR output filter",
+    bio_filter_out_write,
+    bio_filter_out_read,     /* read is never called */
+    bio_filter_out_puts,     /* puts is never called */
+    bio_filter_out_gets,     /* gets is never called */
+    bio_filter_out_ctrl,
+    bio_filter_create,
+    bio_filter_destroy,
+#ifdef OPENSSL_VERSION_NUMBER
+    NULL /* sslc does not have the callback_ctrl field */
+#endif
+};
 
 static BIO_METHOD bio_filter_in_method = {
     BIO_TYPE_MEM,
@@ -575,6 +634,38 @@ static BIO_METHOD bio_filter_in_method =
 #endif
 };
 
+#else
+
+static BIO_METHOD *bio_filter_out_method = NULL;
+static BIO_METHOD *bio_filter_in_method = NULL;
+
+void init_bio_methods(void)
+{
+    bio_filter_out_method = BIO_meth_new(BIO_TYPE_MEM, "APR output filter");
+    BIO_meth_set_write(bio_filter_out_method, &bio_filter_out_write);
+    BIO_meth_set_read(bio_filter_out_method, &bio_filter_out_read); /* read is never called */
+    BIO_meth_set_puts(bio_filter_out_method, &bio_filter_out_puts); /* puts is never called */
+    BIO_meth_set_gets(bio_filter_out_method, &bio_filter_out_gets); /* gets is never called */
+    BIO_meth_set_ctrl(bio_filter_out_method, &bio_filter_out_ctrl);
+    BIO_meth_set_create(bio_filter_out_method, &bio_filter_create);
+    BIO_meth_set_destroy(bio_filter_out_method, &bio_filter_destroy);
+
+    bio_filter_in_method = BIO_meth_new(BIO_TYPE_MEM, "APR input filter");
+    BIO_meth_set_write(bio_filter_in_method, &bio_filter_in_write); /* write is never called */
+    BIO_meth_set_read(bio_filter_in_method, &bio_filter_in_read);
+    BIO_meth_set_puts(bio_filter_in_method, &bio_filter_in_puts);   /* puts is never called */
+    BIO_meth_set_gets(bio_filter_in_method, &bio_filter_in_gets);   /* gets is never called */
+    BIO_meth_set_ctrl(bio_filter_in_method, &bio_filter_in_ctrl);   /* ctrl is never called */
+    BIO_meth_set_create(bio_filter_in_method, &bio_filter_create);
+    BIO_meth_set_destroy(bio_filter_in_method, &bio_filter_destroy);
+}
+
+void free_bio_methods(void)
+{
+    BIO_meth_free(bio_filter_out_method);
+    BIO_meth_free(bio_filter_in_method);
+}
+#endif
 
 static apr_status_t ssl_io_input_read(bio_filter_in_ctx_t *inctx,
                                       char *buf,
@@ -796,8 +887,11 @@ static apr_status_t ssl_filter_write(ap_
     if (filter_ctx->pssl == NULL) {
         return APR_EGENERAL;
     }
-
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
     outctx = (bio_filter_out_ctx_t *)filter_ctx->pbioWrite->ptr;
+#else
+    outctx = (bio_filter_out_ctx_t *)BIO_get_data(filter_ctx->pbioWrite);
+#endif
     res = SSL_write(filter_ctx->pssl, (unsigned char *)data, len);
 
     if (res < 0) {
@@ -1155,10 +1249,17 @@ static int ssl_io_filter_connect(ssl_fil
     }
 
     if ((n = SSL_accept(filter_ctx->pssl)) <= 0) {
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
         bio_filter_in_ctx_t *inctx = (bio_filter_in_ctx_t *)
                                      (filter_ctx->pbioRead->ptr);
         bio_filter_out_ctx_t *outctx = (bio_filter_out_ctx_t *)
                                        (filter_ctx->pbioWrite->ptr);
+#else
+        bio_filter_in_ctx_t *inctx = (bio_filter_in_ctx_t *)
+                                     BIO_get_data(filter_ctx->pbioRead);
+        bio_filter_out_ctx_t *outctx = (bio_filter_out_ctx_t *)
+                                       BIO_get_data(filter_ctx->pbioWrite);
+#endif
         apr_status_t rc = inctx->rc ? inctx->rc : outctx->rc ;
         ssl_err = SSL_get_error(filter_ctx->pssl, n);
 
@@ -1345,7 +1446,7 @@ static apr_status_t ssl_io_filter_Upgrad
     SSL_set_accept_state(ssl);
     SSL_do_handshake(ssl);
 
-    if (SSL_get_state(ssl) != SSL_ST_OK) {
+    if (!SSL_is_init_finished(ssl)) {
         ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "TLS Upgrade handshake failed: "
                       "Not accepted by client!?");
@@ -1476,8 +1577,13 @@ static apr_status_t ssl_io_filter_output
         return ap_pass_brigade(f->next, bb);
     }
 
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
     inctx = (bio_filter_in_ctx_t *)filter_ctx->pbioRead->ptr;
     outctx = (bio_filter_out_ctx_t *)filter_ctx->pbioWrite->ptr;
+#else
+    inctx = (bio_filter_in_ctx_t *)BIO_get_data(filter_ctx->pbioRead);
+    outctx = (bio_filter_out_ctx_t *)BIO_get_data(filter_ctx->pbioWrite);
+#endif
 
     /* When we are the writer, we must initialize the inctx
      * mode so that we block for any required ssl input, because
@@ -1785,8 +1891,13 @@ static void ssl_io_input_add_filter(ssl_
 
     filter_ctx->pInputFilter = ap_add_input_filter(ssl_io_filter, inctx, NULL, c);
 
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
     filter_ctx->pbioRead = BIO_new(&bio_filter_in_method);
     filter_ctx->pbioRead->ptr = (void *)inctx;
+#else
+    filter_ctx->pbioRead = BIO_new(bio_filter_in_method);
+    BIO_set_data(filter_ctx->pbioRead, (void *)inctx);
+#endif
 
     inctx->ssl = ssl;
     inctx->bio_out = filter_ctx->pbioWrite;
@@ -1812,8 +1923,13 @@ void ssl_io_filter_init(conn_rec *c, SSL
     filter_ctx->pOutputFilter   = ap_add_output_filter(ssl_io_filter,
                                                    filter_ctx, NULL, c);
 
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
     filter_ctx->pbioWrite       = BIO_new(&bio_filter_out_method);
     filter_ctx->pbioWrite->ptr  = (void *)bio_filter_out_ctx_new(filter_ctx, c);
+#else
+    filter_ctx->pbioWrite       = BIO_new(bio_filter_out_method);
+    BIO_set_data(filter_ctx->pbioWrite, (void *)bio_filter_out_ctx_new(filter_ctx, c));
+#endif
 
     /* We insert a clogging input filter. Let the core know. */
     c->clogging_input_filters = 1;
diff -rup httpd-2.2.34.orig/modules/ssl/ssl_engine_kernel.c httpd-2.2.34/modules/ssl/ssl_engine_kernel.c
--- httpd-2.2.34.orig/modules/ssl/ssl_engine_kernel.c	2017-01-05 19:55:24.000000000 +0100
+++ httpd-2.2.34/modules/ssl/ssl_engine_kernel.c	2017-11-19 22:20:08.396993982 +0100
@@ -233,7 +233,11 @@ int ssl_hook_Access(request_rec *r)
     X509 *cert;
     X509 *peercert;
     X509_STORE *cert_store = NULL;
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
     X509_STORE_CTX cert_store_ctx;
+#else
+    X509_STORE_CTX *cert_store_ctx;
+#endif
     STACK_OF(SSL_CIPHER) *cipher_list_old = NULL, *cipher_list = NULL;
     const SSL_CIPHER *cipher = NULL;
     int depth, verify_old, verify, n;
@@ -376,7 +380,7 @@ int ssl_hook_Access(request_rec *r)
                      !renegotiate && (n < sk_SSL_CIPHER_num(cipher_list));
                      n++)
                 {
-                    SSL_CIPHER *value = sk_SSL_CIPHER_value(cipher_list, n);
+                    MODSSL_SSL_CIPHER_CONST SSL_CIPHER *value = sk_SSL_CIPHER_value(cipher_list, n);
 
                     if (sk_SSL_CIPHER_find(cipher_list_old, value) < 0) {
                         renegotiate = TRUE;
@@ -387,7 +391,7 @@ int ssl_hook_Access(request_rec *r)
                      !renegotiate && (n < sk_SSL_CIPHER_num(cipher_list_old));
                      n++)
                 {
-                    SSL_CIPHER *value = sk_SSL_CIPHER_value(cipher_list_old, n);
+                    MODSSL_SSL_CIPHER_CONST SSL_CIPHER *value = sk_SSL_CIPHER_value(cipher_list_old, n);
 
                     if (sk_SSL_CIPHER_find(cipher_list, value) < 0) {
                         renegotiate = TRUE;
@@ -705,32 +709,57 @@ int ssl_hook_Access(request_rec *r)
                 cert = sk_X509_value(cert_stack, 0);
             }
 
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
             X509_STORE_CTX_init(&cert_store_ctx, cert_store, cert, cert_stack);
+#else
+            cert_store_ctx = X509_STORE_CTX_new();
+            X509_STORE_CTX_init(cert_store_ctx, cert_store, cert, cert_stack);
+#endif
             depth = SSL_get_verify_depth(ssl);
 
             if (depth >= 0) {
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
                 X509_STORE_CTX_set_depth(&cert_store_ctx, depth);
+#else
+                X509_STORE_CTX_set_depth(cert_store_ctx, depth);
+#endif
             }
 
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
             X509_STORE_CTX_set_ex_data(&cert_store_ctx,
+#else
+            X509_STORE_CTX_set_ex_data(cert_store_ctx,
+#endif
                                        SSL_get_ex_data_X509_STORE_CTX_idx(),
                                        (char *)ssl);
 
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
             if (!modssl_X509_verify_cert(&cert_store_ctx)) {
+#else
+            if (!modssl_X509_verify_cert(cert_store_ctx)) {
+#endif
                 ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                               "Re-negotiation verification step failed");
                 ssl_log_ssl_error(APLOG_MARK, APLOG_ERR, r->server);
             }
 
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
             SSL_set_verify_result(ssl, cert_store_ctx.error);
             X509_STORE_CTX_cleanup(&cert_store_ctx);
-
+#else
+            SSL_set_verify_result(ssl, X509_STORE_CTX_get_error(cert_store_ctx));
+            X509_STORE_CTX_cleanup(cert_store_ctx);
+            X509_STORE_CTX_free(cert_store_ctx);
+#endif
             if (cert_stack != SSL_get_peer_cert_chain(ssl)) {
                 /* we created this ourselves, so free it */
                 sk_X509_pop_free(cert_stack, X509_free);
             }
         }
         else {
+#if ! MODSSL_USE_OPENSSL_PRE_1_1_API
+            char peekbuf[1];
+#endif
             const char *reneg_support;
             request_rec *id = r->main ? r->main : r;
 
@@ -774,7 +803,7 @@ int ssl_hook_Access(request_rec *r)
             SSL_renegotiate(ssl);
             SSL_do_handshake(ssl);
 
-            if (SSL_get_state(ssl) != SSL_ST_OK) {
+            if (!SSL_is_init_finished(ssl)) {
                 ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                               "Re-negotiation request failed");
                 ssl_log_ssl_error(APLOG_MARK, APLOG_ERR, r->server);
@@ -790,12 +819,16 @@ int ssl_hook_Access(request_rec *r)
              * However, this causes failures in perl-framework currently,
              * perhaps pre-test if we have already negotiated?
              */
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
             SSL_set_state(ssl, SSL_ST_ACCEPT);
             SSL_do_handshake(ssl);
+#else
+            SSL_peek(ssl, peekbuf, 0);
+#endif
 
             sslconn->reneg_state = RENEG_REJECT;
 
-            if (SSL_get_state(ssl) != SSL_ST_OK) {
+            if (!SSL_is_init_finished(ssl)) {
                 ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                               "Re-negotiation handshake failed: "
                               "Not accepted by client!?");
@@ -1209,7 +1242,11 @@ DH *ssl_callback_TmpDH(SSL *ssl, int exp
     SSL_set_current_cert(ssl, SSL_CERT_SET_SERVER);
 #endif
     pkey = SSL_get_privatekey(ssl);
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
     type = pkey ? EVP_PKEY_type(pkey->type) : EVP_PKEY_NONE;
+#else
+    type = pkey ? EVP_PKEY_base_id(pkey) : EVP_PKEY_NONE;
+#endif
 
     /*
      * OpenSSL will call us with either keylen == 512 or keylen == 1024
@@ -1371,7 +1408,11 @@ int ssl_callback_SSLVerify_CRL(int ok, X
     SSLSrvConfigRec *sc = mySrvConfig(s);
     SSLConnRec *sslconn = myConnConfig(c);
     modssl_ctx_t *mctx  = myCtxConfig(sslconn, sc);
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
     X509_OBJECT obj;
+#else
+    X509_OBJECT *obj = X509_OBJECT_new();
+#endif
     X509_NAME *subject, *issuer;
     X509 *cert;
     X509_CRL *crl;
@@ -1428,10 +1469,16 @@ int ssl_callback_SSLVerify_CRL(int ok, X
      * Try to retrieve a CRL corresponding to the _subject_ of
      * the current certificate in order to verify it's integrity.
      */
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
     memset((char *)&obj, 0, sizeof(obj));
     rc = SSL_X509_STORE_lookup(mctx->crl,
                                X509_LU_CRL, subject, &obj);
     crl = obj.data.crl;
+#else
+    rc = SSL_X509_STORE_lookup(mctx->crl,
+                               X509_LU_CRL, subject, obj);
+    crl = X509_OBJECT_get0_X509_CRL(obj);
+#endif
 
     if ((rc > 0) && crl) {
         /*
@@ -1474,7 +1521,11 @@ int ssl_callback_SSLVerify_CRL(int ok, X
                          "Invalid signature on CRL");
 
             X509_STORE_CTX_set_error(ctx, X509_V_ERR_CRL_SIGNATURE_FAILURE);
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
             X509_OBJECT_free_contents(&obj);
+#else
+            X509_OBJECT_free(obj);
+#endif
             return FALSE;
         }
 
@@ -1489,7 +1540,11 @@ int ssl_callback_SSLVerify_CRL(int ok, X
 
             X509_STORE_CTX_set_error(ctx,
                                      X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD);
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
             X509_OBJECT_free_contents(&obj);
+#else
+            X509_OBJECT_free(obj);
+#endif
 
             return FALSE;
         }
@@ -1500,23 +1555,39 @@ int ssl_callback_SSLVerify_CRL(int ok, X
                          "revoking all certificates until you get updated CRL");
 
             X509_STORE_CTX_set_error(ctx, X509_V_ERR_CRL_HAS_EXPIRED);
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
             X509_OBJECT_free_contents(&obj);
+#else
+            X509_OBJECT_free(obj);
+#endif
 
             return FALSE;
         }
 
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
         X509_OBJECT_free_contents(&obj);
+#else
+        X509_OBJECT_free(obj);
+#endif
     }
 
     /*
      * Try to retrieve a CRL corresponding to the _issuer_ of
      * the current certificate in order to check for revocation.
      */
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
     memset((char *)&obj, 0, sizeof(obj));
     rc = SSL_X509_STORE_lookup(mctx->crl,
                                X509_LU_CRL, issuer, &obj);
 
     crl = obj.data.crl;
+#else
+    obj = X509_OBJECT_new();
+    rc = SSL_X509_STORE_lookup(mctx->crl,
+                               X509_LU_CRL, issuer, obj);
+    crl = X509_OBJECT_get0_X509_CRL(obj);
+#endif
+
     if ((rc > 0) && crl) {
         /*
          * Check if the current certificate is revoked by this CRL
@@ -1542,13 +1613,21 @@ int ssl_callback_SSLVerify_CRL(int ok, X
                 }
 
                 X509_STORE_CTX_set_error(ctx, X509_V_ERR_CERT_REVOKED);
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
                 X509_OBJECT_free_contents(&obj);
+#else
+                X509_OBJECT_free(obj);
+#endif
 
                 return FALSE;
             }
         }
 
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
         X509_OBJECT_free_contents(&obj);
+#else
+        X509_OBJECT_free(obj);
+#endif
     }
 
     return ok;
@@ -1583,11 +1662,19 @@ static void modssl_proxy_info_log(server
  * so we need to increment here to prevent them from
  * being freed.
  */
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
 #define modssl_set_cert_info(info, cert, pkey) \
     *cert = info->x509; \
     X509_reference_inc(*cert); \
     *pkey = info->x_pkey->dec_pkey; \
     EVP_PKEY_reference_inc(*pkey)
+#else
+#define modssl_set_cert_info(info, cert, pkey) \
+    *cert = info->x509; \
+    X509_up_ref(*cert); \
+    *pkey = info->x_pkey->dec_pkey; \
+    EVP_PKEY_up_ref(*pkey);
+#endif
 
 int ssl_callback_proxy_cert(SSL *ssl, MODSSL_CLIENT_CERT_CB_ARG_TYPE **x509, EVP_PKEY **pkey)
 {
@@ -1679,7 +1766,7 @@ int ssl_callback_proxy_cert(SSL *ssl, MO
 
 static void ssl_session_log(server_rec *s,
                             const char *request,
-                            unsigned char *id,
+                            IDCONST unsigned char *id,
                             unsigned int idlen,
                             const char *status,
                             const char *result,
@@ -1732,8 +1819,12 @@ int ssl_callback_NewSessionCacheEntry(SS
      * Store the SSL_SESSION in the inter-process cache with the
      * same expire time, so it expires automatically there, too.
      */
+#ifdef OPENSSL_NO_SSL_INTERN
+    id = (unsigned char *)SSL_SESSION_get_id(session, &idlen);
+#else
     id = SSL_SESSION_get_session_id(session);
     idlen = SSL_SESSION_get_session_id_length(session);
+#endif
 
     timeout += modssl_session_get_time(session);
 
@@ -1758,7 +1849,7 @@ int ssl_callback_NewSessionCacheEntry(SS
  *  of our other Apache pre-forked server processes.
  */
 SSL_SESSION *ssl_callback_GetSessionCacheEntry(SSL *ssl,
-                                               unsigned char *id,
+                                               IDCONST unsigned char *id,
                                                int idlen, int *do_copy)
 {
     /* Get Apache context back through OpenSSL context */
@@ -1809,8 +1900,12 @@ void ssl_callback_DelSessionCacheEntry(S
     /*
      * Remove the SSL_SESSION from the inter-process cache
      */
+#ifdef OPENSSL_NO_SSL_INTERN
+    id = (unsigned char *)SSL_SESSION_get_id(session, &idlen);
+#else
     id = SSL_SESSION_get_session_id(session);
     idlen = SSL_SESSION_get_session_id_length(session);
+#endif
 
     ssl_scache_remove(s, id, idlen);
 
@@ -1914,9 +2009,13 @@ void ssl_callback_Info(MODSSL_INFO_CB_AR
      * read. */
     if ((where & SSL_CB_ACCEPT_LOOP) && scr->reneg_state == RENEG_REJECT) {
         int state = SSL_get_state(ssl);
-        
+
+#if MODSSL_USE_OPENSSL_PRE_1_1_API 
         if (state == SSL3_ST_SR_CLNT_HELLO_A 
             || state == SSL23_ST_SR_CLNT_HELLO_A) {
+#else
+        if (state == TLS_ST_SR_CLNT_HELLO) {
+#endif
             scr->reneg_state = RENEG_ABORT;
             ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, c,
                           "rejecting client initiated renegotiation");
@@ -2039,13 +2138,18 @@ static int ssl_find_vhost(void *serverna
     sslcon = myConnConfig(c);
     if (found && (ssl = sslcon->ssl) &&
         (sc = mySrvConfig(s))) {
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
         SSL_set_SSL_CTX(ssl, sc->server->ssl_ctx);
+        SSL_set_options(ssl, SSL_CTX_get_options(ssl->ctx));
+#else
+        SSL_CTX *ctx = SSL_set_SSL_CTX(ssl, sc->server->ssl_ctx);
+        SSL_set_options(ssl, SSL_CTX_get_options(ctx));
+#endif
         /*
          * SSL_set_SSL_CTX() only deals with the server cert,
          * so we need to duplicate a few additional settings
          * from the ctx by hand
          */
-        SSL_set_options(ssl, SSL_CTX_get_options(ssl->ctx));
         if ((SSL_get_verify_mode(ssl) == SSL_VERIFY_NONE) ||
             (SSL_num_renegotiations(ssl) == 0)) {
            /*
@@ -2055,8 +2159,13 @@ static int ssl_find_vhost(void *serverna
             * Otherwise, we would possibly reset a per-directory
             * configuration which was put into effect by ssl_hook_Access.
             */
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
             SSL_set_verify(ssl, SSL_CTX_get_verify_mode(ssl->ctx),
                            SSL_CTX_get_verify_callback(ssl->ctx));
+#else
+            SSL_set_verify(ssl, SSL_CTX_get_verify_mode(ctx),
+                           SSL_CTX_get_verify_callback(ctx));
+#endif
         }
 
         /*
diff -rup httpd-2.2.34.orig/modules/ssl/ssl_engine_vars.c httpd-2.2.34/modules/ssl/ssl_engine_vars.c
--- httpd-2.2.34.orig/modules/ssl/ssl_engine_vars.c	2013-02-12 12:51:17.000000000 +0100
+++ httpd-2.2.34/modules/ssl/ssl_engine_vars.c	2017-11-19 22:20:08.396993982 +0100
@@ -291,9 +291,17 @@ static char *ssl_var_lookup_ssl(apr_pool
         char buf[SSL_SESSION_ID_STRING_LEN];
         SSL_SESSION *pSession = SSL_get_session(ssl);
         if (pSession) {
-            result = apr_pstrdup(p, SSL_SESSION_id2sz(
-                                     SSL_SESSION_get_session_id(pSession),
-                                     SSL_SESSION_get_session_id_length(pSession),
+            IDCONST unsigned char *id;
+            unsigned int idlen;
+
+#ifdef OPENSSL_NO_SSL_INTERN
+            id = (unsigned char *)SSL_SESSION_get_id(pSession, &idlen);
+#else
+            id = pSession->session_id;
+            idlen = pSession->session_id_length;
+#endif
+
+            result = apr_pstrdup(p, SSL_SESSION_id2sz(id, idlen,
                                      buf, sizeof(buf)));
         }
     }
@@ -390,13 +398,25 @@ static char *ssl_var_lookup_ssl_cert(apr
         resdup = FALSE;
     }
     else if (strcEQ(var, "A_SIG")) {
-        nid = OBJ_obj2nid((ASN1_OBJECT *)X509_get_signature_algorithm(xs));
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
+        nid = OBJ_obj2nid((ASN1_OBJECT *)(xs->cert_info->signature->algorithm));
+#else
+        const ASN1_OBJECT *paobj;
+        X509_ALGOR_get0(&paobj, NULL, NULL, X509_get0_tbs_sigalg(xs));
+        nid = OBJ_obj2nid(paobj);
+#endif
         result = apr_pstrdup(p,
                              (nid == NID_undef) ? "UNKNOWN" : OBJ_nid2ln(nid));
         resdup = FALSE;
     }
     else if (strcEQ(var, "A_KEY")) {
-        nid = OBJ_obj2nid((ASN1_OBJECT *)X509_get_key_algorithm(xs));
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
+        nid = OBJ_obj2nid((ASN1_OBJECT *)(xs->cert_info->key->algor->algorithm));
+#else
+        ASN1_OBJECT *paobj;
+        X509_PUBKEY_get0_param(&paobj, NULL, 0, NULL, X509_get_X509_PUBKEY(xs));
+        nid = OBJ_obj2nid(paobj);
+#endif
         result = apr_pstrdup(p,
                              (nid == NID_undef) ? "UNKNOWN" : OBJ_nid2ln(nid));
         resdup = FALSE;
@@ -458,15 +478,21 @@ static char *ssl_var_lookup_ssl_cert_dn(
     for (i = 0; ssl_var_lookup_ssl_cert_dn_rec[i].name != NULL; i++) {
         if (strEQn(var, ssl_var_lookup_ssl_cert_dn_rec[i].name, varlen)
             && strlen(ssl_var_lookup_ssl_cert_dn_rec[i].name) == varlen) {
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
             for (j = 0; j < sk_X509_NAME_ENTRY_num((STACK_OF(X509_NAME_ENTRY) *)
                                                  X509_NAME_get_entries(xsname));
                  j++) {
                 xsne = sk_X509_NAME_ENTRY_value((STACK_OF(X509_NAME_ENTRY) *)
                                              X509_NAME_get_entries(xsname), j);
+#else
+            for (j = 0; j < X509_NAME_entry_count(xsname); j++) {
+                xsne = X509_NAME_get_entry(xsname, j);
+#endif
 
                 n =OBJ_obj2nid((ASN1_OBJECT *)X509_NAME_ENTRY_get_object(xsne));
 
                 if (n == ssl_var_lookup_ssl_cert_dn_rec[i].nid && idx-- == 0) {
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
                     unsigned char *data = X509_NAME_ENTRY_get_data_ptr(xsne);
                     /* cast needed from unsigned char to char */
                     result = apr_pstrmemdup(p, (char *)data,
@@ -474,6 +500,9 @@ static char *ssl_var_lookup_ssl_cert_dn(
 #if APR_CHARSET_EBCDIC
                     ap_xlate_proto_from_ascii(result, X509_NAME_ENTRY_get_data_len(xsne));
 #endif /* APR_CHARSET_EBCDIC */
+#else
+                    result = modssl_X509_NAME_ENTRY_to_string(p, xsne);
+#endif
                     break;
                 }
             }
@@ -638,7 +667,7 @@ static char *ssl_var_lookup_ssl_cipher(a
     ssl_var_lookup_ssl_cipher_bits(ssl, &usekeysize, &algkeysize);
 
     if (ssl && strEQ(var, "")) {
-        MODSSL_SSL_CIPHER_CONST SSL_CIPHER *cipher = SSL_get_current_cipher(ssl);
+        const SSL_CIPHER *cipher = SSL_get_current_cipher(ssl);
         result = (cipher != NULL ? (char *)SSL_CIPHER_get_name(cipher) : NULL);
     }
     else if (strcEQ(var, "_EXPORT"))
@@ -659,7 +688,7 @@ static char *ssl_var_lookup_ssl_cipher(a
 
 static void ssl_var_lookup_ssl_cipher_bits(SSL *ssl, int *usekeysize, int *algkeysize)
 {
-    MODSSL_SSL_CIPHER_CONST SSL_CIPHER *cipher;
+    const SSL_CIPHER *cipher;
 
     *usekeysize = 0;
     *algkeysize = 0;
@@ -688,7 +717,9 @@ static char *ssl_var_lookup_ssl_version(
 static void extract_dn(apr_table_t *t, apr_hash_t *nids, const char *pfx, 
                        X509_NAME *xn, apr_pool_t *p)
 {
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
     STACK_OF(X509_NAME_ENTRY) *ents = X509_NAME_get_entries(xn);
+#endif
     X509_NAME_ENTRY *xsne;
     apr_hash_t *count;
     int i, nid;
@@ -698,10 +729,14 @@ static void extract_dn(apr_table_t *t, a
     count = apr_hash_make(p);
 
     /* For each RDN... */
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
     for (i = 0; i < sk_X509_NAME_ENTRY_num(ents); i++) {
-         const char *tag;
-
          xsne = sk_X509_NAME_ENTRY_value(ents, i);
+#else
+    for (i = 0; i < X509_NAME_entry_count(xn); i++) {
+         xsne = X509_NAME_get_entry(xn, i);
+#endif
+         const char *tag;
 
          /* Retrieve the nid, and check whether this is one of the nids
           * which are to be extracted. */
@@ -709,7 +744,6 @@ static void extract_dn(apr_table_t *t, a
 
          tag = apr_hash_get(nids, &nid, sizeof nid);
          if (tag) {
-             unsigned char *data = X509_NAME_ENTRY_get_data_ptr(xsne);
              const char *key;
              int *dup;
              char *value;
@@ -726,13 +760,17 @@ static void extract_dn(apr_table_t *t, a
                  apr_hash_set(count, &nid, sizeof nid, dup);
                  key = apr_pstrcat(p, pfx, tag, NULL);
              }
-             
+#if MODSSL_USE_OPENSSL_PRE_1_1_API 
+             unsigned char *data = X509_NAME_ENTRY_get_data_ptr(xsne);
              /* cast needed from 'unsigned char *' to 'char *' */
              value = apr_pstrmemdup(p, (char *)data,
                                     X509_NAME_ENTRY_get_data_len(xsne));
 #if APR_CHARSET_EBCDIC
              ap_xlate_proto_from_ascii(value, X509_NAME_ENTRY_get_data_len(xsne));
 #endif /* APR_CHARSET_EBCDIC */
+#else
+             value = modssl_X509_NAME_ENTRY_to_string(p, xsne);
+#endif
              apr_table_setn(t, key, value);
          }
     }
@@ -803,8 +841,11 @@ const char *ssl_ext_lookup(apr_pool_t *p
 
     for (j = 0; j < count; j++) {
         X509_EXTENSION *ext = X509_get_ext(xs, j);
-
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
         if (OBJ_cmp(ext->object, oid) == 0) {
+#else
+        if (OBJ_cmp(X509_EXTENSION_get_object(ext), oid) == 0) {
+#endif
             BIO *bio = BIO_new(BIO_s_mem());
 
             if (X509V3_EXT_print(bio, ext, 0, 0) == 1) {
@@ -836,7 +877,11 @@ static char *ssl_var_lookup_ssl_compress
     SSL_SESSION *pSession = SSL_get_session(ssl);
 
     if (pSession) {
+#ifdef OPENSSL_NO_SSL_INTERN
+        switch (SSL_SESSION_get_compress_id(pSession)) {
+#else
         switch (pSession->compress_meth) {
+#endif
         case 0:
             /* default "NULL" already set */
             break;
diff -rup httpd-2.2.34.orig/modules/ssl/ssl_expr_eval.c httpd-2.2.34/modules/ssl/ssl_expr_eval.c
--- httpd-2.2.34.orig/modules/ssl/ssl_expr_eval.c	2007-12-15 09:42:11.000000000 +0100
+++ httpd-2.2.34/modules/ssl/ssl_expr_eval.c	2017-11-19 22:20:08.396993982 +0100
@@ -230,7 +230,12 @@ apr_array_header_t *ssl_extlist_by_oid(r
     for (j = 0; j < count; j++) {
         X509_EXTENSION *ext = X509_get_ext(xs, j);
 
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
         if (OBJ_cmp(ext->object, oid) == 0) {
+#else
+        if (OBJ_cmp(X509_EXTENSION_get_object(ext), oid) == 0) {
+#endif
+
             BIO *bio = BIO_new(BIO_s_mem());
 
             if (X509V3_EXT_print(bio, ext, 0, 0) == 1) {
diff -rup httpd-2.2.34.orig/modules/ssl/ssl_private.h httpd-2.2.34/modules/ssl/ssl_private.h
--- httpd-2.2.34.orig/modules/ssl/ssl_private.h	2017-01-05 19:57:49.000000000 +0100
+++ httpd-2.2.34/modules/ssl/ssl_private.h	2017-11-19 22:20:08.396993982 +0100
@@ -64,9 +64,8 @@
 #define HAVE_TLSV1_X
 #endif
 
-#if !defined(OPENSSL_NO_COMP) && !defined(SSL_OP_NO_COMPRESSION) \
-    && OPENSSL_VERSION_NUMBER < 0x00908000L
-#define OPENSSL_NO_COMP
+#if defined(SSL_CONF_FLAG_FILE)
+#define HAVE_SSL_CONF_CMD
 #endif
 
 #ifndef OPENSSL_NO_TLSEXT
@@ -83,6 +82,36 @@
 #endif
 #endif
 
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
+#define BN_get_rfc2409_prime_768   get_rfc2409_prime_768
+#define BN_get_rfc2409_prime_1024  get_rfc2409_prime_1024
+#define BN_get_rfc3526_prime_1536  get_rfc3526_prime_1536
+#define BN_get_rfc3526_prime_2048  get_rfc3526_prime_2048
+#define BN_get_rfc3526_prime_3072  get_rfc3526_prime_3072
+#define BN_get_rfc3526_prime_4096  get_rfc3526_prime_4096
+#define BN_get_rfc3526_prime_6144  get_rfc3526_prime_6144
+#define BN_get_rfc3526_prime_8192  get_rfc3526_prime_8192
+#define BIO_set_init(x,v)          (x->init=v)
+#define BIO_get_data(x)            (x->ptr)
+#define BIO_set_data(x,v)          (x->ptr=v)
+#define BIO_get_shutdown(x)        (x->shutdown)
+#define BIO_set_shutdown(x,v)      (x->shutdown=v)
+#define DH_bits(x)                 (BN_num_bits(x->p))
+#else
+void init_bio_methods(void);
+void free_bio_methods(void);
+#endif
+
+#if OPENSSL_VERSION_NUMBER < 0x10002000L || defined(LIBRESSL_VERSION_NUMBER)
+#define X509_STORE_CTX_get0_store(x) (x->ctx)
+#endif
+
+#if OPENSSL_VERSION_NUMBER < 0x10000000L
+#ifndef X509_STORE_CTX_get0_current_issuer
+#define X509_STORE_CTX_get0_current_issuer(x) (x->current_issuer)
+#endif
+#endif
+
 #include "ssl_util_ssl.h"
 
 /** The #ifdef macros are only defined AFTER including the above
@@ -664,7 +693,7 @@ int          ssl_callback_SSLVerify(int,
 int          ssl_callback_SSLVerify_CRL(int, X509_STORE_CTX *, conn_rec *);
 int          ssl_callback_proxy_cert(SSL *ssl, MODSSL_CLIENT_CERT_CB_ARG_TYPE **x509, EVP_PKEY **pkey);
 int          ssl_callback_NewSessionCacheEntry(SSL *, SSL_SESSION *);
-SSL_SESSION *ssl_callback_GetSessionCacheEntry(SSL *, unsigned char *, int, int *);
+SSL_SESSION *ssl_callback_GetSessionCacheEntry(SSL *, IDCONST unsigned char *, int, int *);
 void         ssl_callback_DelSessionCacheEntry(SSL_CTX *, SSL_SESSION *);
 void         ssl_callback_Info(MODSSL_INFO_CB_ARG_TYPE, int, int);
 #ifndef OPENSSL_NO_TLSEXT
@@ -679,30 +708,30 @@ int          ssl_callback_SessionTicket(
 void         ssl_scache_init(server_rec *, apr_pool_t *);
 void         ssl_scache_status_register(apr_pool_t *p);
 void         ssl_scache_kill(server_rec *);
-BOOL         ssl_scache_store(server_rec *, UCHAR *, int, time_t, SSL_SESSION *);
-SSL_SESSION *ssl_scache_retrieve(server_rec *, UCHAR *, int);
-void         ssl_scache_remove(server_rec *, UCHAR *, int);
+BOOL         ssl_scache_store(server_rec *, IDCONST UCHAR *, int, time_t, SSL_SESSION *);
+SSL_SESSION *ssl_scache_retrieve(server_rec *, IDCONST UCHAR *, int);
+void         ssl_scache_remove(server_rec *, IDCONST UCHAR *, int);
 
 char        *ssl_scache_id2sz(UCHAR *, int);
 void         ssl_scache_dbm_init(server_rec *, apr_pool_t *);
 void         ssl_scache_dbm_kill(server_rec *);
-BOOL         ssl_scache_dbm_store(server_rec *, UCHAR *, int, time_t, SSL_SESSION *);
-SSL_SESSION *ssl_scache_dbm_retrieve(server_rec *, UCHAR *, int);
-void         ssl_scache_dbm_remove(server_rec *, UCHAR *, int);
+BOOL         ssl_scache_dbm_store(server_rec *, IDCONST UCHAR *, int, time_t, SSL_SESSION *);
+SSL_SESSION *ssl_scache_dbm_retrieve(server_rec *, IDCONST UCHAR *, int);
+void         ssl_scache_dbm_remove(server_rec *, IDCONST UCHAR *, int);
 void         ssl_scache_dbm_status(request_rec *r, int flags, apr_pool_t *pool);
 
 void         ssl_scache_shmcb_init(server_rec *, apr_pool_t *);
 void         ssl_scache_shmcb_kill(server_rec *);
-BOOL         ssl_scache_shmcb_store(server_rec *, UCHAR *, int, time_t, SSL_SESSION *);
-SSL_SESSION *ssl_scache_shmcb_retrieve(server_rec *, UCHAR *, int);
-void         ssl_scache_shmcb_remove(server_rec *, UCHAR *, int);
+BOOL         ssl_scache_shmcb_store(server_rec *, IDCONST UCHAR *, int, time_t, SSL_SESSION *);
+SSL_SESSION *ssl_scache_shmcb_retrieve(server_rec *, IDCONST UCHAR *, int);
+void         ssl_scache_shmcb_remove(server_rec *, IDCONST UCHAR *, int);
 void         ssl_scache_shmcb_status(request_rec *r, int flags, apr_pool_t *pool);
 
 void         ssl_scache_dc_init(server_rec *, apr_pool_t *);
 void         ssl_scache_dc_kill(server_rec *);
-BOOL         ssl_scache_dc_store(server_rec *, UCHAR *, int, time_t, SSL_SESSION *);
-SSL_SESSION *ssl_scache_dc_retrieve(server_rec *, UCHAR *, int);
-void         ssl_scache_dc_remove(server_rec *, UCHAR *, int);
+BOOL         ssl_scache_dc_store(server_rec *, IDCONST UCHAR *, int, time_t, SSL_SESSION *);
+SSL_SESSION *ssl_scache_dc_retrieve(server_rec *, IDCONST UCHAR *, int);
+void         ssl_scache_dc_remove(server_rec *, IDCONST UCHAR *, int);
 void         ssl_scache_dc_status(request_rec *r, int flags, apr_pool_t *pool);
 
 /** Proxy Support */
diff -rup httpd-2.2.34.orig/modules/ssl/ssl_scache.c httpd-2.2.34/modules/ssl/ssl_scache.c
--- httpd-2.2.34.orig/modules/ssl/ssl_scache.c	2006-07-12 05:38:44.000000000 +0200
+++ httpd-2.2.34/modules/ssl/ssl_scache.c	2017-11-19 22:20:08.396993982 +0100
@@ -88,7 +88,7 @@ void ssl_scache_kill(server_rec *s)
     return;
 }
 
-BOOL ssl_scache_store(server_rec *s, UCHAR *id, int idlen, time_t expiry, SSL_SESSION *sess)
+BOOL ssl_scache_store(server_rec *s, IDCONST UCHAR *id, int idlen, time_t expiry, SSL_SESSION *sess)
 {
     SSLModConfigRec *mc = myModConfig(s);
     BOOL rv = FALSE;
@@ -104,7 +104,7 @@ BOOL ssl_scache_store(server_rec *s, UCH
     return rv;
 }
 
-SSL_SESSION *ssl_scache_retrieve(server_rec *s, UCHAR *id, int idlen)
+SSL_SESSION *ssl_scache_retrieve(server_rec *s, IDCONST UCHAR *id, int idlen)
 {
     SSLModConfigRec *mc = myModConfig(s);
     SSL_SESSION *sess = NULL;
@@ -120,7 +120,7 @@ SSL_SESSION *ssl_scache_retrieve(server_
     return sess;
 }
 
-void ssl_scache_remove(server_rec *s, UCHAR *id, int idlen)
+void ssl_scache_remove(server_rec *s, IDCONST UCHAR *id, int idlen)
 {
     SSLModConfigRec *mc = myModConfig(s);
 
diff -rup httpd-2.2.34.orig/modules/ssl/ssl_scache_dbm.c httpd-2.2.34/modules/ssl/ssl_scache_dbm.c
--- httpd-2.2.34.orig/modules/ssl/ssl_scache_dbm.c	2007-11-29 21:21:10.000000000 +0100
+++ httpd-2.2.34/modules/ssl/ssl_scache_dbm.c	2017-11-19 22:20:08.396993982 +0100
@@ -102,7 +102,7 @@ void ssl_scache_dbm_kill(server_rec *s)
     return;
 }
 
-BOOL ssl_scache_dbm_store(server_rec *s, UCHAR *id, int idlen, time_t expiry, SSL_SESSION *sess)
+BOOL ssl_scache_dbm_store(server_rec *s, IDCONST UCHAR *id, int idlen, time_t expiry, SSL_SESSION *sess)
 {
     SSLModConfigRec *mc = myModConfig(s);
     apr_dbm_t *dbm;
@@ -189,7 +189,7 @@ BOOL ssl_scache_dbm_store(server_rec *s,
     return TRUE;
 }
 
-SSL_SESSION *ssl_scache_dbm_retrieve(server_rec *s, UCHAR *id, int idlen)
+SSL_SESSION *ssl_scache_dbm_retrieve(server_rec *s, IDCONST UCHAR *id, int idlen)
 {
     SSLModConfigRec *mc = myModConfig(s);
     apr_dbm_t *dbm;
@@ -264,7 +264,7 @@ SSL_SESSION *ssl_scache_dbm_retrieve(ser
     return sess;
 }
 
-void ssl_scache_dbm_remove(server_rec *s, UCHAR *id, int idlen)
+void ssl_scache_dbm_remove(server_rec *s, IDCONST UCHAR *id, int idlen)
 {
     SSLModConfigRec *mc = myModConfig(s);
     apr_dbm_t *dbm;
diff -rup httpd-2.2.34.orig/modules/ssl/ssl_scache_dc.c httpd-2.2.34/modules/ssl/ssl_scache_dc.c
--- httpd-2.2.34.orig/modules/ssl/ssl_scache_dc.c	2006-07-12 05:38:44.000000000 +0200
+++ httpd-2.2.34/modules/ssl/ssl_scache_dc.c	2017-11-19 22:20:08.396993982 +0100
@@ -97,7 +97,7 @@ void ssl_scache_dc_kill(server_rec *s)
     mc->tSessionCacheDataTable = NULL;
 }
 
-BOOL ssl_scache_dc_store(server_rec *s, UCHAR *id, int idlen,
+BOOL ssl_scache_dc_store(server_rec *s, IDCONST UCHAR *id, int idlen,
                            time_t timeout, SSL_SESSION * pSession)
 {
     unsigned char der[SSL_SESSION_MAX_DER];
@@ -122,7 +122,7 @@ BOOL ssl_scache_dc_store(server_rec *s,
     return TRUE;
 }
 
-SSL_SESSION *ssl_scache_dc_retrieve(server_rec *s, UCHAR *id, int idlen)
+SSL_SESSION *ssl_scache_dc_retrieve(server_rec *s, IDCONST UCHAR *id, int idlen)
 {
     unsigned char der[SSL_SESSION_MAX_DER];
     unsigned int der_len;
@@ -150,7 +150,7 @@ SSL_SESSION *ssl_scache_dc_retrieve(serv
     return pSession;
 }
 
-void ssl_scache_dc_remove(server_rec *s, UCHAR *id, int idlen)
+void ssl_scache_dc_remove(server_rec *s, IDCONST UCHAR *id, int idlen)
 {
     SSLModConfigRec *mc = myModConfig(s);
     DC_CTX *ctx = mc->tSessionCacheDataTable;
diff -rup httpd-2.2.34.orig/modules/ssl/ssl_scache_shmcb.c httpd-2.2.34/modules/ssl/ssl_scache_shmcb.c
--- httpd-2.2.34.orig/modules/ssl/ssl_scache_shmcb.c	2008-08-16 00:15:28.000000000 +0200
+++ httpd-2.2.34/modules/ssl/ssl_scache_shmcb.c	2017-11-19 22:20:08.397993973 +0100
@@ -193,11 +193,11 @@ static void shmcb_cyclic_cton_memcpy(uns
 /* Prototypes for low-level subcache operations */
 static void shmcb_subcache_expire(server_rec *, SHMCBHeader *, SHMCBSubcache *);
 static BOOL shmcb_subcache_store(server_rec *, SHMCBHeader *, SHMCBSubcache *,
-                                 UCHAR *, unsigned int, UCHAR *, time_t);
+                                 UCHAR *, unsigned int, IDCONST UCHAR *, time_t);
 static SSL_SESSION *shmcb_subcache_retrieve(server_rec *, SHMCBHeader *, SHMCBSubcache *,
-                                            UCHAR *, unsigned int);
+                                            IDCONST UCHAR *, unsigned int);
 static BOOL shmcb_subcache_remove(server_rec *, SHMCBHeader *, SHMCBSubcache *,
-                                 UCHAR *, unsigned int);
+                                 IDCONST UCHAR *, unsigned int);
 
 /*
  * High-Level "handlers" as per ssl_scache.c
@@ -338,7 +338,7 @@ void ssl_scache_shmcb_kill(server_rec *s
     return;
 }
 
-BOOL ssl_scache_shmcb_store(server_rec *s, UCHAR *id, int idlen,
+BOOL ssl_scache_shmcb_store(server_rec *s, IDCONST UCHAR *id, int idlen,
                            time_t timeout, SSL_SESSION * pSession)
 {
     SSLModConfigRec *mc = myModConfig(s);
@@ -382,7 +382,7 @@ done:
     return to_return;
 }
 
-SSL_SESSION *ssl_scache_shmcb_retrieve(server_rec *s, UCHAR *id, int idlen)
+SSL_SESSION *ssl_scache_shmcb_retrieve(server_rec *s, IDCONST UCHAR *id, int idlen)
 {
     SSLModConfigRec *mc = myModConfig(s);
     SSL_SESSION *pSession = NULL;
@@ -412,7 +412,7 @@ done:
     return pSession;
 }
 
-void ssl_scache_shmcb_remove(server_rec *s, UCHAR *id, int idlen)
+void ssl_scache_shmcb_remove(server_rec *s, IDCONST UCHAR *id, int idlen)
 {
     SSLModConfigRec *mc = myModConfig(s);
     SHMCBHeader *header = mc->tSessionCacheDataTable;
@@ -561,7 +561,7 @@ static void shmcb_subcache_expire(server
 static BOOL shmcb_subcache_store(server_rec *s, SHMCBHeader *header,
                                  SHMCBSubcache *subcache, 
                                  UCHAR *data, unsigned int data_len,
-                                 UCHAR *id, time_t expiry)
+                                 IDCONST UCHAR *id, time_t expiry)
 {
     unsigned int new_offset, new_idx;
     SHMCBIndex *idx;
@@ -653,7 +653,7 @@ static BOOL shmcb_subcache_store(server_
 }
 
 static SSL_SESSION *shmcb_subcache_retrieve(server_rec *s, SHMCBHeader *header,
-                                            SHMCBSubcache *subcache, UCHAR *id,
+                                            SHMCBSubcache *subcache, IDCONST UCHAR *id,
                                             unsigned int idlen)
 {
     unsigned int pos;
@@ -690,8 +690,12 @@ static SSL_SESSION *shmcb_subcache_retri
                              "shmcb_subcache_retrieve internal error");
                 return NULL;
             }
+#ifdef OPENSSL_NO_SSL_INTERN
+            s_id = (unsigned char *)SSL_SESSION_get_id(pSession, &s_idlen);
+#else
             s_id = SSL_SESSION_get_session_id(pSession);
             s_idlen = SSL_SESSION_get_session_id_length(pSession);
+#endif
             if (s_idlen == idlen && memcmp(s_id, id, idlen) == 0) {
                 /* Found the matching session */
                 ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,
@@ -712,7 +716,7 @@ static SSL_SESSION *shmcb_subcache_retri
 
 static BOOL shmcb_subcache_remove(server_rec *s, SHMCBHeader *header,
                                   SHMCBSubcache *subcache,
-                                  UCHAR *id, unsigned int idlen)
+                                  IDCONST UCHAR *id, unsigned int idlen)
 {
     unsigned int pos;
     unsigned int loop = 0;
@@ -749,8 +753,12 @@ static BOOL shmcb_subcache_remove(server
                              "shmcb_subcache_remove internal error");
                 return FALSE;
             }
+#ifdef OPENSSL_NO_SSL_INTERN
+            s_id = (unsigned char *)SSL_SESSION_get_id(pSession, &s_idlen);
+#else
             s_id = SSL_SESSION_get_session_id(pSession);
             s_idlen = SSL_SESSION_get_session_id_length(pSession);
+#endif
             if (s_idlen == idlen && memcmp(s_id, id, idlen) == 0) {
                 /* Found the matching session, remove it quietly. */
                 idx->removed = 1;
diff -rup httpd-2.2.34.orig/modules/ssl/ssl_toolkit_compat.h httpd-2.2.34/modules/ssl/ssl_toolkit_compat.h
--- httpd-2.2.34.orig/modules/ssl/ssl_toolkit_compat.h	2013-11-11 15:00:57.000000000 +0100
+++ httpd-2.2.34/modules/ssl/ssl_toolkit_compat.h	2017-11-19 22:20:08.397993973 +0100
@@ -30,6 +30,11 @@
 #ifdef HAVE_OPENSSL
 
 /** OpenSSL headers */
+#include <openssl/opensslv.h>
+#if (OPENSSL_VERSION_NUMBER >= 0x10001000)
+/* must be defined before including ssl.h */
+#define OPENSSL_NO_SSL_INTERN
+#endif
 #include <openssl/ssl.h>
 #include <openssl/err.h>
 #include <openssl/x509.h>
@@ -38,6 +43,22 @@
 #include <openssl/evp.h>
 #include <openssl/rand.h>
 #include <openssl/x509v3.h>
+#include <openssl/x509_vfy.h>
+
+#if (OPENSSL_VERSION_NUMBER < 0x0090801f)
+#error mod_ssl requires OpenSSL 0.9.8a or later
+#endif
+
+#define MODSSL_USE_OPENSSL_PRE_1_1_API (OPENSSL_VERSION_NUMBER < 0x10100000L)
+
+/* session id constness */
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
+#define IDCONST
+#define MODSSL_SSL_CIPHER_CONST
+#else
+#define IDCONST const
+#define MODSSL_SSL_CIPHER_CONST const
+#endif
 
 /* ECC support came along in OpenSSL 1.0.0 */
 #if (OPENSSL_VERSION_NUMBER < 0x10000000)
@@ -58,21 +79,23 @@
  */
 
 #define EVP_PKEY_key_type(k)              (EVP_PKEY_type(k->type))
-
 #define X509_NAME_get_entries(xs)         (xs->entries)
-#define X509_REVOKED_get_serialNumber(xs) (xs->serialNumber)
-
 #define X509_get_signature_algorithm(xs) (xs->cert_info->signature->algorithm)
-#define X509_get_key_algorithm(xs)       (xs->cert_info->key->algor->algorithm)
-
 #define X509_NAME_ENTRY_get_data_ptr(xs) (xs->value->data)
 #define X509_NAME_ENTRY_get_data_len(xs) (xs->value->length)
-
 #define SSL_CTX_get_extra_certs(ctx)       (ctx->extra_certs)
 #define SSL_CTX_set_extra_certs(ctx,value) {ctx->extra_certs = value;}
 
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
 #define SSL_CIPHER_get_name(s)             (s->name)
+#define X509_REVOKED_get_serialNumber(xs) (xs->serialNumber)
 #define SSL_CIPHER_get_valid(s)            (s->valid)
+#else
+#define X509_REVOKED_get_serialNumber X509_REVOKED_get0_serialNumber
+#define X509_CRL_get_nextUpdate X509_CRL_get0_nextUpdate
+#define X509_CRL_get_lastUpdate X509_CRL_get0_lastUpdate
+#define RAND_pseudo_bytes RAND_bytes
+#endif
 
 #define SSL_SESSION_get_session_id(s)      (s->session_id)
 #define SSL_SESSION_get_session_id_length(s) (s->session_id_length)
@@ -80,47 +103,47 @@
 /**
  * Support for retrieving/overriding states
  */
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
 #ifndef SSL_get_state
 #define SSL_get_state(ssl) SSL_state(ssl)
 #endif
-
 #define SSL_set_state(ssl,val) (ssl)->state = val
+#endif
 
 #define MODSSL_BIO_CB_ARG_TYPE const char
 #define MODSSL_CRYPTO_CB_ARG_TYPE const char
+
 #if (OPENSSL_VERSION_NUMBER < 0x00907000)
-# define MODSSL_INFO_CB_ARG_TYPE SSL*
+#define MODSSL_INFO_CB_ARG_TYPE SSL*
 #else
-# define MODSSL_INFO_CB_ARG_TYPE const SSL*
+#define MODSSL_INFO_CB_ARG_TYPE const SSL*
 #endif
+
 #define MODSSL_CLIENT_CERT_CB_ARG_TYPE X509
 #define MODSSL_PCHAR_CAST
 
 /** ...shifting sands of openssl... */
 #if (OPENSSL_VERSION_NUMBER >= 0x0090707f)
-# define MODSSL_D2I_SSL_SESSION_CONST    const
-# define MODSSL_SSL_CIPHER_CONST         const
+#define MODSSL_D2I_SSL_SESSION_CONST    const
 #else
-# define MODSSL_D2I_SSL_SESSION_CONST
-# define MODSSL_SSL_CIPHER_CONST
+#define MODSSL_D2I_SSL_SESSION_CONST
 #endif
 
 #if (OPENSSL_VERSION_NUMBER >= 0x00908000)
-# define MODSSL_D2I_PrivateKey_CONST const
-# define MODSSL_D2I_X509_CONST const
+#define MODSSL_D2I_PrivateKey_CONST const
+#define MODSSL_D2I_X509_CONST const
 #else
-# define MODSSL_D2I_PrivateKey_CONST
-# define MODSSL_D2I_X509_CONST
+#define MODSSL_D2I_PrivateKey_CONST
+#define MODSSL_D2I_X509_CONST
 #endif
 
 #if (OPENSSL_VERSION_NUMBER >= 0x00909000)
-# define MODSSL_SSL_METHOD_CONST const
+#define MODSSL_SSL_METHOD_CONST const
 #else
-# define MODSSL_SSL_METHOD_CONST
+#define MODSSL_SSL_METHOD_CONST
 #endif
 
 #define modssl_X509_verify_cert X509_verify_cert
-
 typedef int (modssl_read_bio_cb_fn)(char*,int,int,void*);
 
 #if (OPENSSL_VERSION_NUMBER < 0x00904000)
@@ -130,20 +153,17 @@ typedef int (modssl_read_bio_cb_fn)(char
 #endif
 
 #define modssl_PEM_X509_INFO_read_bio PEM_X509_INFO_read_bio 
-
 #define modssl_PEM_read_bio_PrivateKey PEM_read_bio_PrivateKey
-
 #define modssl_set_cipher_list SSL_set_cipher_list
-
 #define modssl_free OPENSSL_free
-
 #define EVP_PKEY_reference_inc(pkey) \
    CRYPTO_add(&((pkey)->references), +1, CRYPTO_LOCK_X509_PKEY)
-
 #define X509_reference_inc(cert) \
    CRYPTO_add(&((cert)->references), +1, CRYPTO_LOCK_X509)
 
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
 #define HAVE_SSL_RAND_EGD /* since 9.5.1 */
+#endif
 
 #define HAVE_SSL_X509V3_EXT_d2i
 
@@ -168,17 +188,13 @@ typedef int (modssl_read_bio_cb_fn)(char
 #include <evp.h>
 #include <objects.h>
 #include <sslc.h>
-
 /** sslc does not support this function, OpenSSL has since 9.5.1 */
 #define RAND_status() 1
-
 /** sslc names this function a bit differently */
 #define CRYPTO_num_locks() CRYPTO_get_num_locks()
-
 #ifndef STACK_OF
 #define STACK_OF(type) STACK
 #endif
-
 #define MODSSL_BIO_CB_ARG_TYPE char
 #define MODSSL_CRYPTO_CB_ARG_TYPE char
 #define MODSSL_INFO_CB_ARG_TYPE SSL*
@@ -187,52 +203,35 @@ typedef int (modssl_read_bio_cb_fn)(char
 #define MODSSL_D2I_SSL_SESSION_CONST
 #define MODSSL_D2I_PrivateKey_CONST
 #define MODSSL_D2I_X509_CONST
-
 typedef int (modssl_read_bio_cb_fn)(char*,int,int);
-
 #define modssl_X509_verify_cert(c) X509_verify_cert(c, NULL)
-
 #define modssl_PEM_read_bio_X509(b, x, cb, arg) \
    PEM_read_bio_X509(b, x, cb)
-
 #define modssl_PEM_X509_INFO_read_bio(b, x, cb, arg)\
    PEM_X509_INFO_read_bio(b, x, cb)
-
 #define modssl_PEM_read_bio_PrivateKey(b, k, cb, arg) \
    PEM_read_bio_PrivateKey(b, k, cb)
-
 #ifndef HAVE_SSL_SET_STATE
 #define SSL_set_state(ssl, state) /** XXX: should throw an error */
 #endif
-
 #define modssl_set_cipher_list(ssl, l) \
    SSL_set_cipher_list(ssl, (char *)l)
-
 #define modssl_free free
-
 #ifndef PEM_F_DEF_CALLBACK
 #define PEM_F_DEF_CALLBACK PEM_F_DEF_CB
 #endif
-
 #if SSLC_VERSION_NUMBER < 0x2000
-
 #define X509_STORE_CTX_set_depth(st, d)    
 #define X509_CRL_get_lastUpdate(x) ((x)->crl->lastUpdate)
 #define X509_CRL_get_nextUpdate(x) ((x)->crl->nextUpdate)
 #define X509_CRL_get_REVOKED(x)    ((x)->crl->revoked)
 #define X509_REVOKED_get_serialNumber(xs) (xs->serialNumber)
-
 #define modssl_set_verify(ssl, verify, cb) \
     SSL_set_verify(ssl, verify)
-
 #else /** SSLC_VERSION_NUMBER >= 0x2000 */
-
 #define CRYPTO_malloc_init R_malloc_init
-
 #define EVP_cleanup() 
-
 #endif /** SSLC_VERSION_NUMBER >= 0x2000 */
-
 typedef void (*modssl_popfree_fn)(char *data);
 
 #define sk_SSL_CIPHER_dup sk_dup
diff -rup httpd-2.2.34.orig/modules/ssl/ssl_util.c httpd-2.2.34/modules/ssl/ssl_util.c
--- httpd-2.2.34.orig/modules/ssl/ssl_util.c	2013-11-11 15:00:57.000000000 +0100
+++ httpd-2.2.34/modules/ssl/ssl_util.c	2017-11-19 22:20:08.397993973 +0100
@@ -143,7 +143,11 @@ ssl_algo_t ssl_util_algotypeof(X509 *pCe
     if (pCert != NULL)
         pFreeKey = pKey = X509_get_pubkey(pCert);
     if (pKey != NULL) {
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
         switch (EVP_PKEY_key_type(pKey)) {
+#else
+        switch (EVP_PKEY_base_id(pKey)) {
+#endif
             case EVP_PKEY_RSA:
                 t = SSL_ALGO_RSA;
                 break;
@@ -487,4 +491,4 @@ void ssl_util_thread_setup(apr_pool_t *p
     apr_pool_cleanup_register(p, NULL, ssl_util_thread_cleanup,
                                        apr_pool_cleanup_null);
 }
-#endif
+#endif /* #if APR_HAS_THREADS */
diff -rup httpd-2.2.34.orig/modules/ssl/ssl_util_ssl.c httpd-2.2.34/modules/ssl/ssl_util_ssl.c
--- httpd-2.2.34.orig/modules/ssl/ssl_util_ssl.c	2015-05-21 18:05:51.000000000 +0200
+++ httpd-2.2.34/modules/ssl/ssl_util_ssl.c	2017-11-19 22:20:08.397993973 +0100
@@ -192,6 +192,38 @@ int SSL_smart_shutdown(SSL *ssl)
     return rc;
 }
 
+#if ! MODSSL_USE_OPENSSL_PRE_1_1_API
+/* convert an ASN.1 string to a UTF-8 string (escaping control characters) */
+static char *asn1_string_to_utf8(apr_pool_t *p, ASN1_STRING *asn1str)
+{
+    char *result = NULL;
+    BIO *bio;
+    int len;
+
+    if ((bio = BIO_new(BIO_s_mem())) == NULL)
+        return NULL;
+
+    ASN1_STRING_print_ex(bio, asn1str, ASN1_STRFLGS_ESC_CTRL|
+                                       ASN1_STRFLGS_UTF8_CONVERT);
+    len = BIO_pending(bio);
+    if (len > 0) {
+        result = apr_palloc(p, len+1);
+        len = BIO_read(bio, result, len);
+        result[len] = NUL;
+    }
+    BIO_free(bio);
+    return result;
+}
+
+/* convert a NAME_ENTRY to UTF8 string */
+char *modssl_X509_NAME_ENTRY_to_string(apr_pool_t *p, X509_NAME_ENTRY *xsne)
+{
+    char *result = asn1_string_to_utf8(p, X509_NAME_ENTRY_get_data(xsne));
+    ap_xlate_proto_from_ascii(result, len);
+    return result;
+}
+#endif
+
 /*  _________________________________________________________________
 **
 **  Certificate Revocation List (CRL) Storage
@@ -232,12 +264,20 @@ X509_STORE *SSL_X509_STORE_create(char *
 int SSL_X509_STORE_lookup(X509_STORE *pStore, int nType,
                           X509_NAME *pName, X509_OBJECT *pObj)
 {
-    X509_STORE_CTX pStoreCtx;
     int rc;
-
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
+    X509_STORE_CTX pStoreCtx;
     X509_STORE_CTX_init(&pStoreCtx, pStore, NULL, NULL);
     rc = X509_STORE_get_by_subject(&pStoreCtx, nType, pName, pObj);
     X509_STORE_CTX_cleanup(&pStoreCtx);
+#else
+    X509_STORE_CTX *pStoreCtx = X509_STORE_CTX_new();
+    X509_STORE_CTX_init(pStoreCtx, pStore, NULL, NULL);
+    rc = X509_STORE_get_by_subject(pStoreCtx, nType, pName, pObj);
+    X509_STORE_CTX_cleanup(pStoreCtx);
+    X509_STORE_CTX_free(pStoreCtx);
+#endif
+
     return rc;
 }
 
@@ -247,10 +287,11 @@ int SSL_X509_STORE_lookup(X509_STORE *pS
 **  _________________________________________________________________
 */
 
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
 char *SSL_make_ciphersuite(apr_pool_t *p, SSL *ssl)
 {
     STACK_OF(SSL_CIPHER) *sk;
-    SSL_CIPHER *c;
+    MODSSL_SSL_CIPHER_CONST SSL_CIPHER *c;
     int i;
     int l;
     char *cpCipherSuite;
@@ -281,6 +322,7 @@ char *SSL_make_ciphersuite(apr_pool_t *p
     *(cp-1) = NUL;
     return cpCipherSuite;
 }
+#endif
 
 /*  _________________________________________________________________
 **
@@ -360,22 +402,29 @@ BOOL SSL_X509_getCN(apr_pool_t *p, X509
     X509_NAME *xsn;
     X509_NAME_ENTRY *xsne;
     int i, nid;
-    unsigned char *data_ptr;
-    int data_len;
 
     xsn = X509_get_subject_name(xs);
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
     for (i = 0; i < sk_X509_NAME_ENTRY_num((STACK_OF(X509_NAME_ENTRY) *)
                                            X509_NAME_get_entries(xsn)); i++) {
         xsne = sk_X509_NAME_ENTRY_value((STACK_OF(X509_NAME_ENTRY) *)
                                          X509_NAME_get_entries(xsn), i);
+#else
+    for (i = 0; i < X509_NAME_entry_count(xsn); i++) {
+        xsne = X509_NAME_get_entry(xsn, i);
+#endif
         nid = OBJ_obj2nid((ASN1_OBJECT *)X509_NAME_ENTRY_get_object(xsne));
         if (nid == NID_commonName) {
-            data_ptr = X509_NAME_ENTRY_get_data_ptr(xsne);
-            data_len = X509_NAME_ENTRY_get_data_len(xsne);
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
+            unsigned char *data_ptr = X509_NAME_ENTRY_get_data_ptr(xsne);
+            int data_len = X509_NAME_ENTRY_get_data_len(xsne);
             *cppCN = apr_palloc(p, data_len+1);
             apr_cpystrn(*cppCN, (char *)data_ptr, data_len+1);
-            (*cppCN)[data_len] = NUL;
+            (*cppCN)[data_len] = NULL;
             ap_xlate_proto_from_ascii(*cppCN, data_len);
+#else
+            *cppCN = modssl_X509_NAME_ENTRY_to_string(p, xsne);
+#endif
             return TRUE;
         }
     }
@@ -492,6 +541,7 @@ BOOL SSL_X509_INFO_load_path(apr_pool_t
  * format, possibly followed by a sequence of CA certificates that
  * should be sent to the peer in the SSL Certificate message.
  */
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
 int SSL_CTX_use_certificate_chain(
     SSL_CTX *ctx, char *file, int skipfirst, modssl_read_bio_cb_fn *cb)
 {
@@ -501,7 +551,11 @@ int SSL_CTX_use_certificate_chain(
     int n;
     STACK_OF(X509) *extra_certs;
 
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
     if ((bio = BIO_new(BIO_s_file_internal())) == NULL)
+#else
+    if ((bio = BIO_new(BIO_s_file())) == NULL)
+#endif
         return -1;
     if (BIO_read_filename(bio, file) <= 0) {
         BIO_free(bio);
@@ -543,6 +597,7 @@ int SSL_CTX_use_certificate_chain(
     BIO_free(bio);
     return n;
 }
+#endif
 
 /*  _________________________________________________________________
 **
@@ -550,7 +605,7 @@ int SSL_CTX_use_certificate_chain(
 **  _________________________________________________________________
 */
 
-char *SSL_SESSION_id2sz(unsigned char *id, int idlen,
+char *SSL_SESSION_id2sz(IDCONST unsigned char *id, int idlen,
                         char *str, int strsize)
 {
     char *cp;
@@ -592,6 +647,7 @@ DH *modssl_dh_configure(const unsigned c
     }
 
 #if defined(OPENSSL_VERSION_NUMBER) || (SSLC_VERSION_NUMBER < 0x2000)
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
     dh->p = BN_bin2bn(p, plen, NULL);
     dh->g = BN_bin2bn(g, glen, NULL);
     if (!(dh->p && dh->g)) {
@@ -599,6 +655,16 @@ DH *modssl_dh_configure(const unsigned c
         return NULL;
     }
 #else
+    BIGNUM *bnp = BN_bin2bn(p, plen, NULL),
+        *bng = BN_bin2bn(g, glen, NULL);
+    if ((bnp == NULL) || (bng == NULL) || !DH_set0_pqg(dh, bnp, NULL, bng)) {
+        DH_free(dh);
+        BN_free(bnp);
+        BN_free(bng);
+        return NULL;
+    }
+#endif
+#else
     R_EITEMS_add(dh->data, PK_TYPE_DH, PK_DH_P, 0, p, plen, R_EITEMS_PF_COPY);
     R_EITEMS_add(dh->data, PK_TYPE_DH, PK_DH_G, 0, g, glen, R_EITEMS_PF_COPY);
 #endif
diff -rup httpd-2.2.34.orig/modules/ssl/ssl_util_ssl.h httpd-2.2.34/modules/ssl/ssl_util_ssl.h
--- httpd-2.2.34.orig/modules/ssl/ssl_util_ssl.h	2015-05-21 18:05:51.000000000 +0200
+++ httpd-2.2.34/modules/ssl/ssl_util_ssl.h	2017-11-19 22:20:08.397993973 +0100
@@ -43,7 +43,13 @@
 #define SSL_LIBRARY_VERSION OPENSSL_VERSION_NUMBER
 #define SSL_LIBRARY_NAME    "OpenSSL"
 #define SSL_LIBRARY_TEXT    OPENSSL_VERSION_TEXT
+
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
 #define SSL_LIBRARY_DYNTEXT SSLeay_version(SSLEAY_VERSION)
+#else
+#define SSL_LIBRARY_DYNTEXT OpenSSL_version(OPENSSL_VERSION)
+#endif
+
 #elif defined(SSLC_VERSION_NUMBER)
 #define SSL_LIBRARY_VERSION SSLC_VERSION_NUMBER
 #define SSL_LIBRARY_NAME    "SSL-C"
@@ -80,17 +86,23 @@ void        SSL_set_app_data2(SSL *, voi
 X509       *SSL_read_X509(char *, X509 **, modssl_read_bio_cb_fn *);
 EVP_PKEY   *SSL_read_PrivateKey(char *, EVP_PKEY **, modssl_read_bio_cb_fn *, void *);
 int         SSL_smart_shutdown(SSL *ssl);
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
+char       *SSL_make_ciphersuite(apr_pool_t *, SSL *);
+#else
+char       *modssl_X509_NAME_ENTRY_to_string(apr_pool_t *p, X509_NAME_ENTRY *xsne);
+#endif
 X509_STORE *SSL_X509_STORE_create(char *, char *);
 int         SSL_X509_STORE_lookup(X509_STORE *, int, X509_NAME *, X509_OBJECT *);
-char       *SSL_make_ciphersuite(apr_pool_t *, SSL *);
 BOOL        SSL_X509_isSGC(X509 *);
 BOOL        SSL_X509_getBC(X509 *, int *, int *);
 char       *SSL_X509_NAME_to_string(apr_pool_t *, X509_NAME *, unsigned int);
 BOOL        SSL_X509_getCN(apr_pool_t *, X509 *, char **);
 BOOL        SSL_X509_INFO_load_file(apr_pool_t *, STACK_OF(X509_INFO) *, const char *);
 BOOL        SSL_X509_INFO_load_path(apr_pool_t *, STACK_OF(X509_INFO) *, const char *);
+#if MODSSL_USE_OPENSSL_PRE_1_1_API
 int         SSL_CTX_use_certificate_chain(SSL_CTX *, char *, int, modssl_read_bio_cb_fn *);
-char       *SSL_SESSION_id2sz(unsigned char *, int, char *, int);
+#endif
+char       *SSL_SESSION_id2sz(IDCONST unsigned char *, int, char *, int);
 
 /** util functions for OpenSSL+sslc compat */
 int modssl_session_get_time(SSL_SESSION *session);
diff -rup httpd-2.2.34.orig/support/ab.c httpd-2.2.34/support/ab.c
--- httpd-2.2.34.orig/support/ab.c	2017-01-05 19:57:49.000000000 +0100
+++ httpd-2.2.34/support/ab.c	2017-11-19 22:20:08.397993973 +0100
@@ -2037,6 +2037,14 @@ int main(int argc, const char * const ar
     apr_getopt_t *opt;
     const char *optarg;
     char c;
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+    int max_prot = TLS1_2_VERSION;
+#ifndef OPENSSL_NO_SSL3
+    int min_prot = SSL3_VERSION;
+#else
+    int min_prot = TLS1_VERSION;
+#endif
+#endif /* #if OPENSSL_VERSION_NUMBER >= 0x10100000L */
 #ifdef USE_SSL
     AB_SSL_METHOD_CONST SSL_METHOD *meth = SSLv23_client_method();
 #endif
@@ -2240,6 +2248,7 @@ int main(int argc, const char * const ar
                 ssl_cipher = strdup(optarg);
                 break;
             case 'f':
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
                 if (strncasecmp(optarg, "ALL", 3) == 0) {
                     meth = SSLv23_client_method();
 #ifndef OPENSSL_NO_SSL2
@@ -2259,6 +2268,31 @@ int main(int argc, const char * const ar
                 } else if (strncasecmp(optarg, "TLS1", 4) == 0) {
                     meth = TLSv1_client_method();
                 }
+#else /* #if OPENSSL_VERSION_NUMBER < 0x10100000L */
+                meth = TLS_client_method();
+                if (strncasecmp(optarg, "ALL", 3) == 0) {
+                    max_prot = TLS1_2_VERSION;
+#ifndef OPENSSL_NO_SSL3
+                    min_prot = SSL3_VERSION;
+#else
+                    min_prot = TLS1_VERSION;
+#endif
+#ifndef OPENSSL_NO_SSL3
+                } else if (strncasecmp(optarg, "SSL3", 4) == 0) {
+                    max_prot = SSL3_VERSION;
+                    min_prot = SSL3_VERSION;
+#endif
+                } else if (strncasecmp(optarg, "TLS1.1", 6) == 0) {
+                    max_prot = TLS1_1_VERSION;
+                    min_prot = TLS1_1_VERSION;
+                } else if (strncasecmp(optarg, "TLS1.2", 6) == 0) {
+                    max_prot = TLS1_2_VERSION;
+                    min_prot = TLS1_2_VERSION;
+                } else if (strncasecmp(optarg, "TLS1", 4) == 0) {
+                    max_prot = TLS1_VERSION;
+                    min_prot = TLS1_VERSION;
+                }
+#endif /* #if OPENSSL_VERSION_NUMBER < 0x10100000L */
                 break;
 #endif
         }
@@ -2299,8 +2333,10 @@ int main(int argc, const char * const ar
 #ifdef RSAREF
     R_malloc_init();
 #else
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
     CRYPTO_malloc_init();
 #endif
+#endif
     SSL_load_error_strings();
     SSL_library_init();
     bio_out=BIO_new_fp(stdout,BIO_NOCLOSE);
@@ -2312,6 +2348,10 @@ int main(int argc, const char * const ar
         exit(1);
     }
     SSL_CTX_set_options(ssl_ctx, SSL_OP_ALL);
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+    SSL_CTX_set_max_proto_version(ssl_ctx, max_prot);
+    SSL_CTX_set_min_proto_version(ssl_ctx, min_prot);
+#endif
     if (ssl_cipher != NULL) {
         if (!SSL_CTX_set_cipher_list(ssl_ctx, ssl_cipher)) {
             fprintf(stderr, "error setting cipher list [%s]\n", ssl_cipher);
